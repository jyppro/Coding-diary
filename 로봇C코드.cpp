#pragma config(Sensor, S1,     left,           sensorEV3_Color)
#pragma config(Sensor, S3,     middle,          sensorEV3_Color)
#pragma config(Sensor, S4,     right,         sensorEV3_Color)
#pragma config(Motor,  motorB,          ml,            tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          mr,            tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define BLACK_LEVEL 9
#define WHITE_LEVEL 75
#define THRESHOLD ((BLACK_LEVEL+WHITE_LEVEL)/2)
#define WHEEL_RADIUS (56.0/2)
#define PI 3.141592653589793

void PID();
void go();
void go2();
void goleft();
int getMoveEncoderValue(int distance_mm);
void goright();
void turn();

task main()
{
	while (1)
	{
		PID();
		if (getColorReflected(left) <= 10)
		{
			go();
			goleft();
		}
		if (getColorReflected(right) <= 15)
		{
			go2();
			sleep(500);
			if (getColorReflected(left) <= 10) {
				go2();
				go2();
				goleft();
			}
			go2();
			go2();
			if (getColorReflected(middle) <= 15)
			{
				continue;
			}
			goright();
		}
		if (getColorReflected(left) <= 10 && getColorReflected(right) <= 15)
		{
			go();
			goleft();
		}
	}
}
float constrain(float sum, float min, float max) {
	if (sum < min)return min;
	else if (sum > max)return max;
	else return sum;
}
void PID()
{
	int error, sum = 0, last_error, diff = 0, count = 0;
	const int v = 25;
	const float Kp = 0.25;
	const float Ki = 0.005;
	const int Kd = 3;
	waitForButtonPress();
	while (1)
	{
		sleep(1);
		error = getColorReflected(middle) - THRESHOLD;
		sum = constrain(sum + error, -1000, 1000);
		diff = error - last_error;
		setMotorSpeed(ml, v + (error *Kp + sum * Ki + diff * Kd));
		setMotorSpeed(mr, v - (error *Kp + sum * Ki + diff * Kd));
		last_error = error;
		if (getColorReflected(left) <= 10) //left turn
			return;
		if (getColorReflected(right) <= 15) //right turn
			return;
		if (getColorReflected(left) >= 50 && getColorReflected(right) >= 50 && getColorReflected(middle) >= 50)// 3color white = turn
		{
			count++;
		}
		if (count >= 600)
		{
			turn();
		}
		if (getColorReflected(middle) <= 15)
			count = 0;
	}
}
void go() {
	int v = 10, enco, distance = 88;
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	enco = 0;
	enco = getMoveEncoderValue(distance);
	setMotorTarget(ml, enco, v);
	setMotorTarget(mr, enco, v);
	waitUntilMotorStop(ml);
	waitUntilMotorStop(mr);
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	setMotorSpeed(ml, 0);
	setMotorSpeed(mr, 0);
	sleep(500);
}
void go2() {
	int v = 10, enco, distance = 30;
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	enco = 0;
	enco = getMoveEncoderValue(distance);
	setMotorTarget(ml, enco, v);
	setMotorTarget(mr, enco, v);
	waitUntilMotorStop(ml);
	waitUntilMotorStop(mr);
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	setMotorSpeed(ml, 0);
	setMotorSpeed(mr, 0);
}
void goleft() {
	int v = 10, enco, distance = 82;
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	enco = 0;
	enco = getMoveEncoderValue(distance);
	setMotorTarget(ml, -enco, v);
	setMotorTarget(mr, +enco, v);
	waitUntilMotorStop(ml);
	waitUntilMotorStop(mr);
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	setMotorSpeed(ml, 0);
	setMotorSpeed(mr, 0);
	sleep(500);
}
int getMoveEncoderValue(int distance_mm)
{
	return (distance_mm*360.0) / (2 * PI*WHEEL_RADIUS);
}

void goright() {
	int v = 10, enco, distance = 82;
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	enco = 0;
	enco = getMoveEncoderValue(distance);
	setMotorTarget(ml, +enco, v);
	setMotorTarget(mr, -enco, v);
	waitUntilMotorStop(ml);
	waitUntilMotorStop(mr);
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	setMotorSpeed(ml, 0);
	setMotorSpeed(mr, 0);
	sleep(500);
}

void turn() {
	int v = 10, enco, distance = 180;
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	enco = 0;
	enco = getMoveEncoderValue(distance);
	setMotorTarget(ml, -enco, v);
	setMotorTarget(mr, +enco, v);
	waitUntilMotorStop(ml);
	waitUntilMotorStop(mr);
	resetMotorEncoder(ml);
	resetMotorEncoder(mr);
	setMotorSpeed(ml, 0);
	setMotorSpeed(mr, 0);
	sleep(500);
}
